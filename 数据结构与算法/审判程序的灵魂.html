<script>
	/*
					算法效率的度量
		一:事后统计法
			a.比较不同算法对同一组输入数据的运行处理时间。
			缺陷：
				a.为了获得不同算法的运行时间必须编写相应程序。
				b.运行时间严重依赖硬件以及运行时的环境因素。
				c.算法的测试数据的选取相当困难。
			总结:事后统计法虽然直观，但是实施困难且缺陷多，一般不予考虑。
		二:事前分析估算
			a.依据统计的方法对算法效率进行估算。
			影响算法效率的主要因素：
				a.算法采用的策略和方法。
				b.问题的输入规模。
				c.编译器所产生的代码。
				d.计算机执行速度。
		function fn_sun(array,len){
			var i =0;         1
			var j=0;			1
			var s=0;			1
			for(i=0;i<len;i++){
				for(j=0;j<len;j++){
					s+=i*j;			n*n（关键部分）
				}
			}
			return s;  1
		}
		t = (n*n+4)*T;
		T:js程序执行代码时间
		启示:
		a.随着问题规模n的增大，它们操作数量的差异会越来越大，因此实际算法在时间效率上的差异性会变得非常明显!
		b.判断一个算法的效率时，往往只需要关注操作数量的“最高次项”，其他次要项和常数项可以忽略。
						  大O表示法
		  a.算法效率严重“依赖”于“操作(Operation)数量”。
		  b.在判断时首先关注操作数量的“最高次项”。
		  c.操作数量的估算可以作为时间复杂度的估算。
		  	O(5) = O(1)
		  	O(2n+1) = O(2n) =O(n)
		  	O(n*n+n+1) = O(n*n)
		  	O(3*n*n*n+1) =O(3*n*n*n)= O(n*n*n+1)
		 常见的时间复杂度类型:
			执行函数           阶          非正式术语
			12				  O(1)            常数阶
			2n+3              O(n)            线性阶
			3n*n+2*n_1        O(n*n)          平方价
			5log2n+20         O(logn)         对数阶
			2n+3nlog2n+19     O(nlogn)        nlogn阶
			6n*n*n+2n*n+3n+4  O(n*n*n)        立方阶
			2的n次方          O(2的n次方)     指数阶
		关系:
		O(1)<O(logn)<O(n)<O(nlogn)<O(n*n)<O(n*n*n)<O(2的n次方)<
		O(n!)<O{n的n次方}
							最坏与最好
	function search(array,len,n){
		var ret =-1;
		var i=0;
		for(i=0;i<len;i++){
			if(array[i]==n){
				ret = i;
				break;
			}
		}
		return ret;
	}
	var array = [1,2,3,4,5];
	console.log(search(array,5,1));  最好的情况，复杂度O(1)
	console.log(search(array,5,5));  最坏的情况, 复杂度O(n)
		意义:
		当算法在最坏情况下仍然能满足需求时，可以推断，算法的最好情况和平均情况都满足需求。
						空间与时间的策略
		a.多数情况下，算法执行时“所用的时间”更令人关注。
		b.如果有必要，可以通过增加空间复杂度来降低时间复杂度。
		c.同理，也可以通过增加时间复杂度来降低空间复杂度。
							注意：
		在实现算法时，需要分享具体问题对执行时间和空间的要求。
	*/
</script>